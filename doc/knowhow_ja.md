# Polaris Navigator ビルドノウハウ

## 概要

このドキュメントはPolaris Navigatorのビルドプロセスに関するノウハウと一般的な問題解決方法をまとめています。

## ビルド環境

- **Arduino IDE**: 最新版を使用
- **ボード**: M5Stack AtomS3R
- **ボード設定**: m5stack:esp32:m5stack_atoms3r
- **Arduino CLI**: C:\Program Files\Arduino IDE\resources\app\lib\backend\resources\arduino-cli.exe

## ビルドコマンド

```bash
& "C:\Program Files\Arduino IDE\resources\app\lib\backend\resources\arduino-cli.exe" compile --fqbn m5stack:esp32:m5stack_atoms3r .
```

## 一般的なビルドエラーと解決方法

### 1. 関数宣言と定義の不一致

**エラー例**:
```bash
function expects X arguments, Y provided
```

**解決方法**:
- ヘッダファイル(.h)での関数宣言と、実装ファイル(.cpp)での関数定義の引数が一致しているか確認
- 呼び出し側のコードが正しい数の引数を渡しているか確認

### 2. 未定義のシンボル

**エラー例**:
```
'SYMBOL_NAME' was not declared in this scope
```

**解決方法**:
- 必要なヘッダファイルがインクルードされているか確認
- 定数名が正しいか確認（例：TFT_GRAYではなくTFT_DARKGREYを使用）
- 名前空間の指定が必要な場合は追加

### 3. 関数の重複定義

**エラー例**:
```
'function_name' previously defined here
```

**解決方法**:
- 同じ関数が複数の場所で定義されていないか確認
- クラスメソッドの場合、クラス名::メソッド名の形式で定義されているか確認

### 4. メンバー関数の未定義

**エラー例**:
```
'CLASS_NAME' has no member named 'FUNCTION_NAME'
```

**解決方法**:
- クラスのヘッダファイルに関数が宣言されているか確認
- 関数名のスペルミスがないか確認
- 継承関係を確認（親クラスのメソッドを呼び出している場合）

### 5. ライブラリの問題

**エラー例**:
```
No such file or directory
```

**解決方法**:
- 必要なライブラリがインストールされているか確認
- ライブラリのバージョンが互換性があるか確認
- インクルードパスが正しいか確認

### 6. C++のメソッド実装順序の問題

**エラー例**:
```
'methodName's scope
```

**解決方法**:
- C++では、メソッドの実装順序が重要です。あるメソッドが別のメソッドを呼び出す場合、呼び出されるメソッドを先に実装する必要があります。
- 循環参照がある場合は、前方宣言を使用するか、実装を分割する必要があります。
- クラスのメソッドをprivateからpublicに変更することで解決できる場合もあります。

### 7. M5Stackハードウェア固有の問題

**エラー例**:
```
'm5::M5Unified' has no member named 'dis'
```

**解決方法**:
- AtomS3Rなど特定のM5Stackデバイスでは、LEDやディスプレイの制御方法が異なります。
- AtomS3RではLEDの制御に`M5.dis`ではなく`M5.Lcd.fillScreen()`を使用します。
- ハードウェア固有の機能を使用する場合は、デバイスのドキュメントを確認してください。

### 8. 未実装メソッドの問題

**エラー例**:
```
undefined reference to 'ClassName::methodName'
```

**解決方法**:
- ヘッダファイル(.h)で宣言されているメソッドが実装ファイル(.cpp)で実装されていない場合に発生します。
- すべての宣言されたメソッドが実装されているか確認してください。
- 使用していないメソッドは宣言から削除するか、空の実装を提供してください。

### 9. ライブラリマクロとの名前競合

**エラー例**:
```
expected unqualified-id before numeric constant
```

**解決方法**:
- ESP32のlwIPライブラリなど、システムライブラリで定義されているマクロ名と競合していないか確認
- 特に `RAW_DEBUG` のような一般的な名前は、ライブラリですでに定義されている可能性がある
- 競合する場合は、プロジェクト固有のプレフィックスを付けるか（例：`PN_DEBUG`）、別の名前に変更する（例：`DISPLAY_DEBUG`）

### 10. 重複したケース値

**エラー例**:
```
duplicate case value
```

**解決方法**:
- switchステートメント内で同じ値を持つcaseが複数定義されていないか確認
- 列挙型で同じ値を持つ複数の定数を定義している場合、switchステートメントでは一つだけ使用する
- エイリアスとして同じ値を持つ列挙型を定義する場合は、コメントで明示する

## デバッグのヒント

1. **シリアルモニタの活用**: 
   - 重要な変数の値や処理の流れをシリアル出力で確認
   - `Serial.print()` や `Serial.println()` を戦略的に配置

2. **段階的なビルド**:
   - 大きな変更を一度に行わず、小さな変更ごとにビルドして問題を特定

3. **コメントアウト**:
   - 問題のある可能性がある部分を一時的にコメントアウトして、エラーの原因を特定

4. **プリプロセッサの活用**:
   - `#ifdef DEBUG` などの条件付きコンパイルを使用してデバッグコードを管理

5. **段階的なエラー解決**:
   - エラーメッセージを注意深く読み、問題の箇所を特定します。
   - 複数のエラーがある場合は、最初のエラーから順に解決します。

6. **コードの簡略化**:
   - 複雑な実装を一時的に簡略化して、基本的な機能が動作するか確認します。
   - 動作確認後、段階的に元の実装に戻します。

7. **依存関係の確認**:
   - メソッド間の呼び出し関係を確認し、循環参照がないか確認します。
   - クラス間の依存関係を最小限に抑えます。

8. **ビルドフラグの活用**:
   - `-v`（詳細）フラグを使用して、より詳細なビルド情報を取得します。
   ```bash
   & "C:\Program Files\Arduino IDE\resources\app\lib\backend\resources\arduino-cli.exe" compile --fqbn m5stack:esp32:m5stack_atoms3r . -v
   ```

## 特定の機能に関するノウハウ

### IMUセンサー

- AtomS3Rには、BMI270（6軸加速度・ジャイロセンサー）とBMM150（3軸地磁気センサー）の9軸センサーシステムが搭載
- 校正状態は3段階（GOOD、OK、POOR）で表示され、校正されていない場合は「NOT CALIBRATED」と表示

#### AtomS3R IMUセンサー詳細仕様
- **センサー特性**
  - BMI270
    - 加速度計: ±4G範囲、変換係数 8192.0f (INT16_to_G)
    - ジャイロスコープ: ±2000dps範囲、変換係数 16.384f (INT16_to_DPS)
  - BMM150
    - 磁力計: マイクロテスラ(uT)単位で測定

#### 校正機能実装ガイドライン
- **校正ステージ**
  - 3段階の校正プロセスを実装（磁力計、加速度計、ジャイロスコープ）
  - 校正状態表示: GOOD(3)、OK(2)、POOR(1)、NOT CALIBRATED(0)
  - 色分け表示: GOOD(緑)、OK(黄)、POOR(オレンジ)、NOT CALIBRATED(赤)

- **校正手順ガイダンス**
  - 磁力計: 8の字を描くように回転させる
  - 加速度計/ジャイロスコープ: デバイスをあらゆる方向にひっくり返す
  - 校正中はLEDを黄色に点滅させる視覚的フィードバック

- **校正の限界と注意点**
  - M5Unifiedライブラリの基本校正機能はオフセットバイアスのみを推定
  - 完全な校正にはスケールバイアスも測定が必要
  - 高度な校正にはMotionCalなどの外部ツールを推奨

#### IMUデータ表示ガイドライン
- **センサーデータ表示**
  - ジャイロスコープデータ: deg/s単位、緑色で表示
  - 加速度計データ: m/s²単位、黄色で表示
  - 磁力計データ: uT単位、マゼンタ色で表示

- **傾き表示の視覚化**
  - ピッチとロールを円の位置で視覚的に表現
  - シアン色のマーカー：目標高度（北極星）
  - 黄色の三角形：現在の傾き（ピッチ）
  - 白色のマーカー：中央位置
  - AtomS3Rの小さな画面に合わせて表示位置を最適化（y=110に固定）

- **データ構造設計**
  - IMUデータはフラットな構造体で管理
  - センサー種別ごとにX/Y/Z軸の値を明確に区別
  - デバッグ出力を整理し、シリアルコンソールで確認可能に

#### 参考実装リソース
- **公式リファレンス**
  - M5Stack AtomS3R工場デモコード: https://github.com/m5stack/M5AtomS3-UserDemo/tree/atoms3r
  - BMI270/BMM150実装例: https://github.com/m5stack/M5AtomS3-UserDemo/blob/atoms3r/platforms/atoms3r/main/hal_atom_s3r/utils/bmi270/src/bmi270.cpp

- **コミュニティリソース**
  - 9軸IMU実装例: https://github.com/bareboat-necessities/bbn-atomS3R/
  - 高度な磁力計校正ツール: https://github.com/bareboat-necessities/bbn-MotionCal

### GPS

- AtomicBase GPS: GPS_TX_PIN = 5, GPS_RX_PIN = -1
- GPSデータの表示には、緯度、経度、高度、衛星数、HDOP、時刻情報が必要

### ディスプレイ

- スプライトを使用したダブルバッファリングを実装
- `_sprite` がnullの場合は直接ディスプレイに描画する分岐処理が必要

### LEDとディスプレイの制御

- **LEDの制御**:
  - AtomS3Rでは、内蔵LEDの制御に`M5.Lcd.fillScreen(color)`を使用します。
  - 色は32ビットRGB形式（0xRRGGBB）で指定します。

- **ディスプレイのダブルバッファリング**:
  - スプライトを使用したダブルバッファリングを実装することで、ちらつきを軽減できます。
  - スプライトが初期化できない場合は、直接ディスプレイに描画する分岐処理を実装してください。

### アニメーション実装のヒント

- **パルスアニメーション**:
  - 明るさを時間とともに変化させる場合は、サインカーブを使用すると自然な変化が得られます。
  - 長時間のアニメーションはバッテリー消費が大きいため、短時間で効果的なアニメーションを心がけます。

- **回転アニメーション**:
  - HSVカラースペースを使用すると、色相の回転アニメーションが実装しやすくなります。
  - 回転方向を指定できるようにすると、より多様な視覚効果が得られます。

### 天体情報表示機能

#### 実装のポイント
- **太陽・月の位置表示**
  - 方位角（Azimuth）と高度（Altitude）を計算し、コンパスローズ上に表示
  - 太陽は黄色、月は白色のマーカーで視覚的に区別
  - 方位角を円周上の位置に変換する計算式: `centerX + radius * sin(azimuth * PI / 180.0)`

- **月齢表示**
  - 月齢は0〜29.53の値で、新月（0）から満月（約14.76）、再び新月へのサイクル
  - `getMoonIllumination()`メソッドで月の輝面比率（%）を計算
  - 月齢に応じたアイコンや数値で表示

- **スプライト処理**
  - ダブルバッファリングのためのスプライト使用が推奨
  - スプライトが初期化されていない場合のフォールバック処理も実装
  - `_sprite->pushSprite(0, 0)`でスプライトをディスプレイに転送

- **LED表示**
  - 天体データ表示中はLEDを紫色（`COLOR_PURPLE`）に設定
  - `setPixelColor()`メソッドを使用（`setPixel()`ではない）
  - 各表示モードで異なる色を使い、視覚的にモードを区別

#### 一般的な問題と解決策
- **方位角計算の問題**
  - 方位角は0〜360度の範囲で、北を0度として時計回りに増加
  - 表示時は数学的な角度（反時計回り、東を0度）に変換が必要
  - 変換式: `screenAngle = 90 - compassAngle`（北を上にする場合）

- **スプライト関連のエラー**
  - `_sprite`がnullの場合に`_sprite->method()`を呼び出すとクラッシュ
  - 必ず`if (_sprite) { ... } else { ... }`の形式でnullチェックを行う
  - スプライトのメモリ解放を忘れないよう注意（`delete _sprite`）

- **LED制御の問題**
  - AtomS3Rでは`setPixel()`ではなく`setPixelColor()`を使用
  - 色定数は`COLOR_RED`などの定義済み定数を使用
  - LEDの更新頻度が高すぎるとちらつきの原因になるため注意

#### パフォーマンス最適化
- 天体位置の計算は計算コストが高いため、必要な時だけ更新
- 表示更新と計算更新の頻度を分けて実装（表示は毎フレーム、計算は数秒ごと）
- 小数点以下の精度は必要最小限に抑える（例：`%.1f`形式で十分）

## M5AtomS3デバイスでの表示調整

### 画面サイズと表示位置

M5AtomS3の小さな画面（128x128ピクセル）に合わせて表示を調整する際のポイント：

- **テキスト位置の最適化**:
  - 行間を詰めて（例：10px → 5px）より多くの情報を表示
  - 重要な情報を画面上部に配置し、スクロールなしで見えるようにする

- **グラフィック要素のサイズ調整**:
  - コンパスローズの半径を小さくする（例：40px → 30px）
  - 中心位置を上部に移動して（例：centerY = 150 → 110）画面内に収める

- **方位表示の工夫**:
  - 方位記号（N, E, S, W）を追加して視認性を向上
  - 北を示す線は赤色で強調し、方向を明確に

- **フォントサイズと色**:
  - 重要な情報は大きめのフォントで表示
  - ステータス情報は色分けして視認性を向上（例：有効=緑、無効=赤）

### アップロード時の注意点

- デバイスがダウンロードモードになっていることを確認してからアップロード
- ダウンロードモードにするには、リセットボタンを押しながらUSB接続するか、接続状態でリセットボタンを長押し
- アップロード失敗時は「No serial data received」などのエラーが表示される
- アップロードコマンド例：
  ```bash
  arduino-cli upload -p COM10 --fqbn m5stack:esp32:m5stack_atoms3r Polaris_Navigator
  ```

## パフォーマンスの最適化

1. **メモリ使用量の削減**:
   - 大きな配列や文字列は必要最小限に
   - 動的メモリ割り当ては避け、静的割り当てを優先

2. **描画処理の最適化**:
   - 必要な部分のみを更新
   - スプライトを使用したダブルバッファリングの活用

3. **電力消費の最適化**:
   - 不要なセンサーの電源を切る
   - 処理間隔を適切に設定

## 継続的な改善

- エラーが発生した場合は、このドキュメントに追加して知識を蓄積
- 解決方法を見つけたら、コードにコメントとして残すことも検討

## ビルドエラーの解決方法とGitHub CLIの使用方法に関するノウハウ

### 1. 未実装メソッドによるビルドエラー

**エラー例**:
```
undefined reference to `CompassDisplay::showCelestialData(float, float, float, float, int)'
```

**解決方法**:
- ヘッダファイル(.h)で宣言されているメソッドが実装ファイル(.cpp)で実装されていない場合に発生します。
- 宣言と同じシグネチャ（引数の型と数、戻り値の型）で実装を追加します。
- 実装例:
  ```cpp
  void CompassDisplay::showCelestialData(float sunAzimuth, float sunAltitude, float moonAzimuth, float moonAltitude, int moonPhase) {
    // 実装内容
  }
  ```

### 2. メソッド名の不一致によるエラー

**エラー例**:
```
'setPixel' was not declared in this scope
```

**解決方法**:
- クラス内で定義されているメソッド名と呼び出しているメソッド名が一致しているか確認します。
- 例: `setPixel()`を呼び出している場合、実際のメソッド名が`setPixelColor()`であれば、呼び出し側を修正します。
- AtomS3Rでは、LEDの制御に`setPixelColor()`を使用します（`setPixel()`ではない）。

## M5Stack ATOMS3Rのダウンロードモード

M5Stack ATOMS3Rにコードをアップロードする際、デバイスをダウンロードモードに移行する必要があります。この操作は一人で行うのが難しい場合があるため、他の人に手伝ってもらうと効率的です。

### 1. ダウンロードモードへの移行方法

- **基本手順**:
  - USBケーブルを接続する前に、デバイスのボタンを押したままにする
  - USBケーブルを接続
  - デバイスが接続されたら（2-3秒後）、ボタンを離す

- **協力体制**:
  - 一人がボタンを押し続け、もう一人がUSBケーブルを接続
  - または、ボタンを押した状態でUSBケーブルを接続できるよう工夫する

### 2. ダウンロードモード中の注意点

- ダウンロードモード中はデバイスの画面が暗くなるか、特定のパターンを表示
- アップロード完了後、デバイスは自動的に再起動する
- アップロードに失敗した場合は、再度ダウンロードモードに移行する必要がある

### 3. トラブルシューティング

- **ポートが見つからない**:
  - デバイスがダウンロードモードになっていない可能性がある
  - USBケーブルの品質によっては接続が不安定になることがある
  - 別のUSBポートを試す

- **アップロードの失敗**:
  - 再度ダウンロードモードに移行して試す
  - Arduino IDEを再起動する
  - USBケーブルを交換する

### 4. SPIFFSデータのアップロード

SPIFFSにデータをアップロードする際も同様にダウンロードモードが必要です：

- **手順**:
  - Arduino IDEの「ツール」→「ESP32 Sketch Data Upload」を選択
  - デバイスをダウンロードモードに移行（上記と同じ手順）
  - アップロードが完了するまで待機

- **注意点**:
  - SPIFFSのアップロードはスケッチのアップロードより時間がかかることがある
  - アップロード中はPCとの接続を切断しない
  - 大きなファイルをアップロードする場合は特に注意が必要

## GitHub CLIを使用したプルリクエスト作成

GitHub CLIを使用すると、コマンドラインからGitHubのプルリクエストを作成できます。

### 1. GitHub CLIのインストール確認

```powershell
# GitHub CLIがインストールされているか確認
& "C:\Program Files\GitHub CLI\gh.exe" --version
```

### 2. GitHub CLIでの認証

```powershell
# 初回使用時は認証が必要
& "C:\Program Files\GitHub CLI\gh.exe" auth login
```

### 3. プルリクエストの作成

```powershell
# カレントブランチからプルリクエストを作成
& "C:\Program Files\GitHub CLI\gh.exe" pr create --title "タイトル" --body "説明文"
```

### 4. プルリクエストの確認

```powershell
# 作成したプルリクエストの一覧を表示
& "C:\Program Files\GitHub CLI\gh.exe" pr list
```

### 5. プルリクエストのステータス確認

```powershell
# 特定のプルリクエストの詳細を表示
& "C:\Program Files\GitHub CLI\gh.exe" pr view [PR番号]
```

GitHub CLIを使用すると、ブラウザを開かずにプルリクエストの作成や管理ができるため、開発ワークフローが効率化されます。

## 機能実装のノウハウ

### GPS機能

- **AtomicBase GPS接続**:
  - GPS_TX_PIN = 5
  - GPS_RX_PIN = -1（AtomicBase GPSを使用する場合）
  - ピン設定が正しいことを確認してください

- **GPSデータの保存と再利用**:
  - GPSデータはフラッシュメモリに保存され、信号が得られない場合に再利用されます
  - 更新頻度は60分に一度に設定し、フラッシュメモリの寿命を考慮しています
  - `Preferences`ライブラリを使用してデータを保存します

### UI実装

- **仰角インジケーター**:
  - 極軸合わせモードで北極星の高度と現在の傾きを視覚的に表示
  - シアン色のマーカー：目標高度（北極星）
  - 黄色の三角形：現在の傾き（ピッチ）
  - 白色のマーカー：中央位置
  - AtomS3Rの小さな画面に合わせて表示位置を最適化（y=110に固定）

- **モード切り替え**:
  - RAW_DATAモードのサブモード（IMU、GPS、CELESTIAL、SYSTEM、DEBUG）を一周した後、直接初期画面に戻るよう実装
  - `cycleRawDataMode()`関数でモード遷移を管理

- **表示レイアウト**:
  - タイトルは画面上部（y=0）に統一して表示
  - コンテンツが重ならないよう余白を調整
  - 小さな画面に多くの情報を表示するため、略語や色分けを活用

## ディスプレイとメモリ管理の課題

### メモリ制約とスプライト処理

- **AtomS3Rのメモリ制約**:
  - AtomS3Rは限られたメモリリソースしか持ちません
  - スプライトを使用する表示メソッドがメモリ不足で失敗

- **直接描画 vs スプライト**:
  - スプライトベースのレンダリングは滑らかな更新を提供しますが、より多くのメモリを必要とします
  - ディスプレイへの直接描画はメモリ効率が良いですが、視覚的なアーティファクトを引き起こす可能性があります
  - `_useDirectDraw`フラグを実装して、これらのモードを切り替えられるようにしました

- **ボタン処理の課題**:
  - ボタン押下時にスプライト操作と組み合わせるとメモリアクセス違反が発生することがあります
  - すべての表示メソッドに直接描画モードを実装しましたが、問題は完全に解決しませんでした
  - ボタン処理と表示更新の相互作用についてさらなる調査が必要です

### 得られた教訓

1. **メモリ管理が重要**:
   - AtomS3Rのようなリソース制約のあるデバイスでは、慎重なメモリ管理が不可欠です
   - 大きなバッファを割り当てる前に、利用可能なメモリを常に確認してください
   - スプライト作成時に`createSprite`の戻り値を確認し、失敗した場合の対策を講じてください

2. **グレースフルデグラデーション**:
   - リソース集約型の操作が失敗した場合のフォールバックメカニズムを実装してください
   - 例えば、スプライト作成が失敗した場合は直接描画モードに切り替えるなど
   - ユーザー体験を維持するために、機能を段階的に低下させる戦略を検討してください

3. **デバッグ情報**:
   - 特にメモリ関連の問題について診断するために、包括的なデバッグ出力を含めてください
   - シリアル出力を活用して、メモリ使用量や処理フローを監視してください
   - エラー発生時に詳細な情報を提供することで、問題解決が容易になります

4. **根本原因分析**:
   - 問題に対処する際は、回避策を実装するのではなく、根本原因を特定して修正することに焦点を当ててください
   - この対症療法ではなく根本的解決のアプローチにより、長期的にはより堅牢なソリューションが得られます

### 今後の課題

- メモリ効率と視覚的品質のバランスを取る表示管理の代替アプローチを検討する
- メモリアクセス違反を防ぐためにボタン処理を最適化する
- モード遷移を安全に処理するためのより堅牢な状態管理システムの実装を検討する
- 限られたメモリリソースでの効率的なグラフィック処理方法の研究

## M5AtomS3デバイスでの表示調整

### 画面サイズと表示位置

M5AtomS3の小さな画面（128x128ピクセル）に合わせて表示を調整する際のポイント：

- **テキスト位置の最適化**:
  - 行間を詰めて（例：10px → 5px）より多くの情報を表示
  - 重要な情報を画面上部に配置し、スクロールなしで見えるようにする
  - 画面下部の限られたスペース（例：下部18ピクセル）に情報を集約して表示

- **グラフィック要素のサイズ調整**:
  - コンパスローズの半径を小さくする（例：40px → 30px）
  - 中心位置を上部に移動して（例：centerY = 150 → 110）画面内に収める

- **方位表示の工夫**:
  - 方位記号（N, E, S, W）を追加して視認性を向上
  - 北を示す線は赤色で強調し、方向を明確に

- **フォントサイズと色**:
  - 重要な情報は大きめのフォントで表示
  - ステータス情報は色分けして視認性を向上（例：有効=緑、無効=赤）
  - 起動時のメッセージは白色（TFT_WHITE）で統一し、視認性を向上
  - 長いメッセージは短く簡潔にして、重なりを防止（例：「Initializing IMU...」→「IMU」）

### 起動画面の最適化

- **起動画面の表示領域**:
  - 画面下部18ピクセルの領域に2行のテキストを表示
  - 1行目：現在の処理内容（例：「IMU」、「GPS」など）
  - 2行目：ステータス情報（例：「OK」、「Failed」など）

- **プログレスバーの削除**:
  - メモリ使用量削減と表示の簡素化のため、プログレスバーを削除
  - 代わりに簡潔なテキストメッセージのみを表示
  - 進捗パーセント表示も削除し、視覚的なノイズを低減

- **表示エリアのクリア**:
  - 新しいメッセージを表示する前に、表示エリアを黒色（TFT_BLACK）で消去
  - これにより、テキストの重なりを防止し、読みやすさを向上

- **実装例**:
```cpp
// 画面下部18ピクセルに2行だけで表示
M5.Display.fillRect(0, M5.Display.height() - 18, M5.Display.width(), 18, TFT_BLACK);
M5.Display.setTextColor(TFT_WHITE);
M5.Display.setTextSize(1.0);
M5.Display.setCursor(5, M5.Display.height() - 18);
M5.Display.println("IMU OK");
M5.Display.setCursor(5, M5.Display.height() - 8);
M5.Display.printf("A:%s G:%s M:%s", accOk?"OK":"NG", gyroOk?"OK":"NG", magOk?"OK":"NG");
```

### アップロード時の注意点

- デバイスがダウンロードモードになっていることを確認してからアップロード
- ダウンロードモードにするには、リセットボタンを押しながらUSB接続するか、接続状態でリセットボタンを長押し
- アップロード失敗時は「No serial data received」などのエラーが表示される
- アップロードコマンド例：
  ```bash
  arduino-cli upload -p COM10 --fqbn m5stack:esp32:m5stack_atoms3r Polaris_Navigator
  ```

## パフォーマンスの最適化

1. **メモリ使用量の削減**:
   - 大きな配列や文字列は必要最小限に
   - 動的メモリ割り当ては避け、静的割り当てを優先
   - 不要な機能（PNGローダー、SPIFFSなど）を削除してメモリを節約
   - 画像データ（ロゴなど）を削除し、テキストベースの表示に切り替え

2. **描画処理の最適化**:
   - 必要な部分のみを更新
   - スプライトを使用したダブルバッファリングの活用
   - メモリ制約がある場合は直接描画モード（_useDirectDraw）を使用
   - 表示内容を簡素化し、必要最小限の情報のみを表示

3. **電力消費の最適化**:
   - 不要なセンサーの電源を切る
   - 処理間隔を適切に設定

4. **UI応答性の向上**:
   - 長い遅延（delay）を避ける
   - ボタン処理を最優先で行う
   - 表示更新と内部処理を分離し、応答性を確保

## AtomS3Rデバイスのメモリ管理

### メモリアクセス違反の防止

- **症状**: ボタンを押すとメモリアクセス違反（LoadProhibited）によりリブートが発生
- **原因**: スプライトを使用する表示メソッドがメモリ不足で失敗

- **対策**:
  - 直接描画モード（_useDirectDraw）を実装し、スプライト使用時のメモリ不足を回避
  - すべての表示メソッドを直接描画モードに対応させる
  - デフォルトで直接描画モードを使用するように設定
  - 不要な機能や大きなデータ構造を削除してメモリを節約

- **実装例**:
```cpp
// 表示メソッドの例（直接描画モード対応）
void CompassDisplay::showPolarAlignment(float azimuth, float altitude) {
  // 描画先を決定（スプライトまたは直接ディスプレイ）
  auto& target = _useDirectDraw ? M5.Display : *_sprite;
  
  // 以下、targetに対して描画処理を行う
  target.fillScreen(TFT_BLACK);
  // ...
}
```

### グレースフルデグラデーション

- メモリ制約のあるデバイスでは、機能を段階的に縮小する「グレースフルデグラデーション」を実装
- 主要機能（極軸合わせなど）を優先し、装飾的な要素（ロゴ、アニメーションなど）は削除
- エラー発生時にも最低限の機能を維持できるよう、フォールバックメカニズムを実装

### メモリ使用量の監視

- 定期的にメモリ使用量を確認し、リークや過剰な使用を検出
- 特に問題が発生しやすい操作（ボタン押下、画面切り替えなど）の前後でメモリ使用量をログ出力
- 実装例:
```cpp
Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
```

## IMUの座標系と軸の調整

### AtomS3R IMUの座標系

AtomS3Rデバイスの物理的な向きとIMUの座標系の関係を正しく定義することが重要です：

- **物理的な座標系の定義**:
  - X軸: デバイスの右方向（USBコネクタが下向きの場合）
  - Y軸: デバイスの上方向（USBコネクタが下向きの場合）
  - Z軸: デバイスの画面から外向き（画面に垂直）

- **極軸合わせ時の標準的な持ち方**:
  - デバイスの上面（-X方向）を天の北極/南極に向ける
  - ディスプレイ面を上向きにして読みやすくする

- **角度の定義**:
  - ピッチ: X-Z平面での傾き（+/-90度）、0度が水平
  - ロール: Y-Z平面での傾き（+/-180度）、0度が水平
  - 方位角: 北を0度とした水平面内での角度（0-360度）

### IMUデータの軸調整

M5Unifiedライブラリから取得したIMUデータは、AtomS3Rデバイスの物理的な向きと直接対応していないため、軸の調整が必要です：

```cpp
// 加速度データの軸調整（軸の入れ替えと符号の反転）
acc_adj[0] = acc[1];  // X軸をY軸に変更（デバイスの上方向を右方向と再定義）
acc_adj[1] = -acc[0]; // Y軸を-X軸に変更（デバイスの右方向を下方向と再定義）
acc_adj[2] = acc[2];  // Z軸はそのまま（画面垂直方向）

// 地磁気データの軸調整（加速度と同様の調整）
mag_adj[0] = mag[1];  // X軸をY軸に変更
mag_adj[1] = -mag[0]; // Y軸を-X軸に変更
mag_adj[2] = mag[2];  // Z軸はそのまま
```

### ピッチとロールの計算

調整後の軸データを使用して、ピッチとロールを正確に計算します：

```cpp
// ピッチ: X-Z平面での傾き（+/-90度）
pitch = atan2(acc_adj[0], sqrt(acc_adj[1] * acc_adj[1] + acc_adj[2] * acc_adj[2])) * 180.0 / PI;

// ロール: Y-Z平面での傾き（+/-180度）
roll = atan2(acc_adj[1], acc_adj[2]) * 180.0 / PI;
```

### 方位角計算のティルト補正

地磁気データを使用して方位角を計算する際、デバイスの傾き（ピッチとロール）を考慮したティルト補正が必要です：

```cpp
// 地磁気データをティルト補正
float mag_x = mag_adj[0] * cos(pitch_rad) + mag_adj[2] * sin(pitch_rad);
float mag_y = mag_adj[0] * sin(roll_rad) * sin(pitch_rad) + 
             mag_adj[1] * cos(roll_rad) - 
             mag_adj[2] * sin(roll_rad) * cos(pitch_rad);

// 補正後の地磁気データから方位角を計算
heading = atan2(mag_y, mag_x) * 180.0 / PI;
```

### 軸調整の検証方法

IMUの軸調整が正しいかどうかを検証するには：

1. **ピッチの検証**: デバイスを前後に傾けると、ピッチの値のみが変化し、ロールは安定しているはず
2. **ロールの検証**: デバイスを左右に傾けると、ロールの値のみが変化し、ピッチは安定しているはず
3. **方位角の検証**: デバイスを水平に保ちながら回転させると、方位角が0〜360度の範囲で変化するはず

### 一般的な問題と解決策

- **問題**: デバイスをロール方向に傾けるとピッチが変化する
  - **原因**: IMUの軸の対応関係が正しくない
  - **解決策**: 軸の入れ替えと符号の反転を行う

- **問題**: 方位角が不安定または不正確
  - **原因**: 地磁気センサーの校正不足または外部磁気干渉
  - **解決策**: 地磁気センサーの校正を実施し、磁気干渉源から離れる

- **問題**: ピッチとロールの値が予想と逆
  - **原因**: 軸の符号が逆
  - **解決策**: 該当する軸の符号を反転（例: `acc_adj[0] = -acc[1]`）

## 起動画面とロゴ表示

### ロゴ表示の実装

- **概要**: 起動画面にロゴを表示し、初期化プロセス中も維持する機能
- **実装方法**:
  - `icon.h`からロゴデータを読み込み、起動画面上部に表示
  - 画面下部18ピクセルをステータスメッセージ用に確保
  - 初期化メッセージ表示時は下部領域のみをクリア

- **実装例**:
```cpp
// ロゴ表示（StartupScreen.cpp）
void StartupScreen::drawLogo() {
  // ロゴを画面上部に表示
  M5.Display.drawBitmap(
    (M5.Display.width() - LOGO_WIDTH) / 2, 
    10, 
    LOGO_WIDTH, 
    LOGO_HEIGHT, 
    logoData
  );
}

// 初期化進捗表示（下部18ピクセルのみクリア）
void StartupScreen::showInitProgress(const char* message, int progressPercent) {
  // 下部18ピクセルのみをクリア
  M5.Display.fillRect(0, M5.Display.height() - 18, M5.Display.width(), 18, TFT_BLACK);
  
  // メッセージを表示
  M5.Display.setTextColor(TFT_WHITE);
  M5.Display.setCursor(5, M5.Display.height() - 18);
  M5.Display.printf("%s", message);
}
```

### 画面輝度の一貫性確保

- **問題**: 初期化完了時に画面輝度が変化して見える
- **原因**: LED色の変更が画面の見え方に影響
- **解決策**:
  - 輝度を明示的に再設定（40%に統一）
  - LED色を暗めの緑色（0x007F00）に調整
  - 初期化完了メッセージを中央揃えに変更

- **実装例**:
```cpp
void StartupScreen::showInitComplete() {
  // 下部18ピクセルのみをクリア
  M5.Display.fillRect(0, M5.Display.height() - 18, M5.Display.width(), 18, TFT_BLACK);
  
  // 輝度を明示的に再設定
  M5.Display.setBrightness(40);
  
  // メッセージを中央に表示
  M5.Display.setTextColor(TFT_WHITE);
  int textWidth = 12 * 12; // "Init Complete"の幅を概算
  int xPos = (M5.Display.width() - textWidth) / 2;
  M5.Display.setCursor(xPos, M5.Display.height() - 12);
  M5.Display.println("Init Complete");
  
  // 暗めの緑色を使用
  setLedColor(0x007F00);
  
  // 表示を確認するための短い遅延
  delay(1000);
}
```

### 実装上の注意点

1. **部分的な画面クリア**:
   - 全画面クリア（`fillScreen`）を避け、必要な部分のみ（`fillRect`）をクリアする
   - これにより、ロゴが初期化プロセス中も表示され続ける

2. **LED色と画面の見え方**:
   - RGB LEDの色が明るすぎると、画面の見え方（特に輝度）に影響する
   - 暗めの色を使用するか、輝度を明示的に再設定する

3. **メモリ使用量の最適化**:
   - ロゴデータは静的配列として保存し、動的メモリ割り当てを避ける
   - 必要最小限のサイズでロゴを作成し、メモリ使用量を抑える

## IMUとコンパスのケアレスミス防止策

IMUとコンパスの実装では、以下のようなケアレスミスが発生しやすいため、特に注意が必要です。

#### 方位角計算のケアレスミス防止

1. **atan2関数の引数順序**:
   - 正しい方位角計算には引数の順序が重要です
   - 北を0度とする標準的な方位角計算: `atan2(mag_y, mag_x) * 180.0 / PI`
   - 引数を逆にすると90度ずれた方位角になります
   - 実装前に必ず座標系と方位角の定義を確認してください

2. **単位変換の一貫性**:
   - ラジアンと度の混同に注意
   - 計算には`RAD_TO_DEG`（57.29578...）または`* 180.0 / PI`を使用
   - 表示用の角度計算には`* PI / 180.0`を使用
   - 単位変換の定数を明示的に定義し、一貫して使用する

3. **座標系の統一**:
   - プロジェクト全体で一貫した座標系を使用する
   - AtomS3Rの座標系を明確にドキュメント化し、すべての実装で参照する
   - 複数のクラスで座標変換を行う場合は、共通のユーティリティ関数を使用する

#### 表示関連のケアレスミス防止

1. **角度の向きと原点**:
   - 画面上での角度は通常、上が0度、時計回りに増加
   - 方位角は北が0度、時計回りに増加（東が90度、南が180度、西が270度）
   - 画面上で北を上に表示するには、方位角を反転（`-heading`）する必要がある場合がある
   - 角度計算のコメントに明示的に記述し、混乱を防止する

2. **条件付き表示の注意点**:
   - 条件付き表示（`if (condition) { draw... }`）は意図しない非表示の原因になりやすい
   - 重要な表示要素には条件を最小限にする
   - デバッグモードで条件の評価結果をシリアル出力で確認する

3. **座標計算の検証**:
   - 表示要素の座標計算が正しいか視覚的に確認する
   - 固定位置の要素（北極星など）は条件に依存せず常に表示されるようにする
   - 座標計算にマジックナンバーを使用せず、定数または明示的な計算式を使用する

## 起動画面とロゴ表示
{{ ... }}
```
